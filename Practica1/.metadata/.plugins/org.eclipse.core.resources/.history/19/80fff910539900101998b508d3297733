#include <stdio.h>
#include "xparameters.h"
#include "xil_cache.h"
#include "xgpio.h"
#include "gpio_header.h"
#include "xbasic_types.h"

#define DEBUG 1
#define LEDS_CHANNEL 0
#define SWITCHES_CHANNEL 1


/*
 * Recibe un byte de la UART y lo devuelve como char
 */
char readCharFromUART(){

	Xuint8 caracter = XUartLite_RecvByte(XPAR_AXI_UARTLITE_0_BASEADDR);
	return (char)caracter;
}

/*
 * Manda el caracter c a la UART
 */
void sendCharToUART(char c){

	XUartLite_SendByte(XPAR_UARTLITE_0_BASEADDR, c);

	if(DEBUG == 1){
		xil_printf("\rUART should receive: %c\n\r", c);
	}
}

/*
 * Lee un digito de la UART y lo devuelve.
 * Si hay algun error, devuelve -1
 */
int readDigitFromUART(){

	char c = readCharFromUART();
	if('0' <= c && c <= '9')
		return c -'0';
	else
		return -1;
}

/*
 * Lee un numero de varios digitos de la UART y lo devuelve.
 * La funcion no retorna hasta leer un numero válido
 */
int getNumber(){

	Xuint8 byte;
	Xuint8 uartBuffer[10];
	Xboolean validNumber;
	int digitIndex;
	int digit, number, sign;
	int c;

	while(1){
		byte = 0x00;
		digit = 0;
		digitIndex = 0;
		number = 0;
		validNumber = XTRUE;

		//get bytes from uart until RETURN is entered
		while(byte != 0x0d){
			byte = XUartLite_RecvByte(XPAR_UARTLITE_0_BASEADDR);
			uartBuffer[digitIndex] = byte;
			XUartLite_SendByte(XPAR_UARTLITE_0_BASEADDR, byte);
			digitIndex++;
		}

		//calculate number from string of digits
		for(c = 0; c < (digitIndex - 1); c++){
			if(c == 0){
				//check if first byte is a "-"
				if(uartBuffer[c] == 0x2D){
					sign = -1;
					digit = 0;
				}
				//check if first byte is a digit
				else if((uartBuffer[c] >> 4) == 0x03){
					sign = 1;
					digit = (uartBuffer[c] & 0x0F);
				}
				else
					validNumber = XFALSE;
			}
			else {
				//check byte is a digit
				if((uartBuffer[c] >> 4) == 0x03)
					digit = (uartBuffer[c] & 0x0F);
				else
					validNumber = XFALSE;
			}
			number = (number * 10) + digit;
		}

		number *= sign;
		if(validNumber == XTRUE) {
			return number;
		}
		print("This is not a valid number.\n\r");
	}
}

/*
 * Muestra un entero en los LEDS en binario
 */
int showNumberOnLEDS(int n){

	XGpio gpio;
	int status;

	status = XGipio_Initialize(&gpio, XPAR_AXI_GPIO_0_DEVICE_ID);
	if(status != XST_SUCCESS)
		return XST_FAILURE;

	XGpio_SetDataDirection(&gpio, LEDS_CHANNEL, 0x0);
	XGpio_DiscreteWrite(&gpio, LEDS_CHANNEL, Xuint16(n));

	if(DEBUG == 1){
		xil_printf("Mostrando numero %d en los leds\n\r", n);
	}
}

/*
 * Muestra un entero en pantalla
 */
void showNumberOnScreen(int n){

}

/*
 * Mostrar menu de opciones
 */
void showMenu(){

	xil_printf("a.-Introducir primer operando y visualizarlo en los leds y en pantalla\n\r");
	xil_printf("b.-Introducir segundo operando y visualizarlo en los leds y en pantalla\n\r");
	xil_printf("c.-Sumar y visualizar el resultado en los leds y en la pantalla\n\r");
	xil_printf("d.-Restar y visualizar el resultado en los leds y en la pantalla\n\r");
	xil_printf("e.-Salir\n\r");
}


int main () 
{
   Xil_ICacheEnable();
   Xil_DCacheEnable();
   print("---Entering main---\n\r");

   int exit = 0;
   char option;
   int primero, segundo;
   while(exit == 0){

	   showMenu();
	   option = readCharFromUART();
	   switch(option){

	   xil_printf("Opcion %c\n\r", option);

	   case 'a':
		   primero = getNumber();
		   showNumberOnLEDS(primero);
		   break;

	   case 'b':
		   segundo = getNumber();
		   showNumberOnLEDS(segundo);
		   break;

	   case 'c':
		   break;

	   case 'd':
		   break;

	   case 'e':
		   break;

	   default:
		   break;
	   }

   }

   print("---Exiting main---\n\r");
   Xil_DCacheDisable();
   Xil_ICacheDisable();
   return 0;
}
